# 泛型

泛型可以使编译期间代码的错误更容易侦测。简单来说，在定义类，接口和方法时，可以将类型（类和接口）作为参数。类型参数可以更好的重用代码。

使用泛型的好处：

- 编译期间更强的类型检查。
- 避免使用类型转化。
- 实现泛型算法。使算法更通用。



## 泛型类型

带有类型参数的泛型类或接口。

### 泛型类定义

```java
class name<T1,T2,...,Tn> {/*...*/}
```

尖括号中的参数列表表示可接受的类型。类型参数可以是任何非元类型，即：类，接口，数组甚至另一种类型变量。

### 类型参数命名惯例

一般是单个的大写字母。

- E - Element(Java Collections Framework中大量使用)
- K - Key
- N - Number
- T - Type
- V - Value
- S，U，V 等等 - 第二，第三，第四类型

```java
Box<Integer> integerBox;
Box<Integer> integerBox = new Box<Integer>();
Box<Integer> integerBox = new Box<>();//SE7之后
```

### 多类型参数

#### 定义

```java
//接口
public interface Pair<K, V> {
    public K getKey();
    public V getValue();
}
//类
public class OrderedPair<K, V> implements Pair<K, V> {

    private K key;
    private V value;

    public OrderedPair(K key, V value) {
	this.key = key;
	this.value = value;
    }

    public K getKey()	{ return key; }
    public V getValue() { return value; }
}
```

#### 实例化

```java
Pair<String, Integer> p1 = new OrderedPair<String, Integer>("Even", 8);
Pair<String, String>  p2 = new OrderedPair<String, String>("hello", "world");

//SE7
Pair<String, Integer> p1 = new OrderedPair<>("Even", 8);
Pair<String, String>  p2 = new OrderedPair<>("hello", "world");
```

### 参数化类型

可使用参数化类型当作类型参数。

```java
OrderedPair<String, Box<Integer>> p = new OrderedPair<>("primes", new Box<Integer>(...));
//声明时不允许。没有必要
public interface Pair<K, Box<T>> {
    public K getKey();
    public V getValue();
}
```

### 原生类型

不带任何**实参**的泛型类或者接口。

```java
public class Box<T>{
    public void set(T t){}
}
//原生类型。本质上rawBox是Object。
Box rawBox = new Box();

//为了后向兼容，将参数化类型赋值给它的原生类型是可以的。
Box<String> stringBox = new Box<>();
rawBox = stringBox;

rawBox.set(8);//使用原生类型调用泛型方法，会产生警告：未检查的调用

Box<Integer> intBox = rawBox ；//警告：未检查的转换
    

```

**注意：**非泛型类或方法不是原生类型。

这些警告表明原生类型忽略了类型检查。

#### Unchecked 错误信息

当混用泛型代码和非泛型代码时，或许会得到如下警告：

```java
Note: Example.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.//Unchecked 默认关闭，可使用-Xlint:unchecked重新编译获得额外信息
//-Xlint:-unchecked可完全关闭该warning
//@SuppressingWarnings("unchecked") 设置不显示
```

## 泛型方法

带有自己类型参数的方法，类型参数的范围限于定义它的方法。静态和非静态的方法都允许，也允许泛型的类构造器。

将泛型方法中出现的类型参数使用`<>`包起来，放在返回值之前。

```java
public class Util {
    public static <K, V> boolean compare(Pair<K, V> p1, Pair<K, V> p2) {
        return p1.getKey().equals(p2.getKey()) &&
               p1.getValue().equals(p2.getValue());
    }
}

boolean same = Util.<Integer, String>compare(p1, p2);
boolean same = Util.<>compare(p1, p2);//类型参数可省略
```

## 边界类型参数

限制类型参数的边界。

语法：

```java
<T1,T2 extends C1&I1&I2,...,Tn>
```

**注意：**此处的extends 即可以指继承，也可以指实现。其后可跟类和接口，同时若有类，则类必须在第一位。

限定边界的类型参数可使用其边界中的方法。

```java
public class NaturalNumber<T extends Integer> {

    private T n;

    public NaturalNumber(T n)  { this.n = n; }

    public boolean isEven() {
        return n.intValue() % 2 == 0;//使用边界类中的方法
    }

    // ...
}
```

### 泛型方法和边界类型参数

可以很方便的实现泛型算法。例如，实现一个统计数组中大于某指定元素的元素的个数。

```java
public static <T> int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e > elem)  // compiler error.
            ++count;
    return count;
}
```

上述代码编译错误，是因为`>`只能用于比较元类型，不能比较对象。为修复该问题。做如下修改：

```java
public interface Comparable<T> {
    public int compareTo(T o);
}
//使类型T实现Comparable<T>以便能够正常比较
public static <T extends Comparable<T>> int countGreaterThan(T[] anArray, T elem) {
    int count = 0;
    for (T e : anArray)
        if (e.compareTo(elem) > 0)
            ++count;
    return count;
}
```

## 泛型，继承，子类型

```java
Box<Number> box = new Box<Number>();
box.add(new Integer(10));   // OK
box.add(new Double(10.1));  // OK


public void boxTest(Box<Number> n) { /* ... */ }
Box<Integer> bi = new Box<>();
boxTest(bi);//not OK
```

![](./imgs/generics-subtypeRelationship.gif)



如上图所示，Integer是Number 的子类型。但是`Box<Number>`和`Box<Integer>`之间没有任何关系。想要创建两个相关的泛型类型，需要使用Wildcards 。

### 泛型类和子类型

可以继承泛型类型和实现泛型接口。两个类的类型参数之间的关系取决于extends 和 implements 子句。

使用Collections类做个例子，`ArrayList<E>` 实现了`List<E>`。`List<E>`继承了`Collection<E>`。所以，`ArrayList<String>`是`List<String>`的子类型，`List<String>`是`Collection<String>`的子类型。

假如现在要实现一个新的类：

```java
interface PayloadList<E,P> extends List<E> {
  void setPayload(int index, P val);
  ...
}
```

![](./imgs/generics-payloadListHierarchy.gif)

则类的继承关系如上图所示。

## 类型推断

