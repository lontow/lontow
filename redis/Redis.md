# Redis

## NoSQL数据库简介

集群中session 的存储。

- 存到　cookies
- 复制
- NoSQL 存储

减少IO 压力

- 缓存数据库

### 定义

**Not Only SQL**　。泛指非关系型数据库

**key-value** 存储,性能优先。（内存中）

不支持 ACID

### 使用场景

- 高并发
- 海量数据读写
- 高可扩展性

### 常见NoSQL 数据库

- Memcache
- Redis
  - 支持各种数据类型
  - 支持持久化
  - 单线程+多路复用
- MongoDB

## Redis6 的概述和安装

默认16个数据库。默认为0号

### 单线程＋多路IO复用技术

## 常用五大数据类型

### string

- 二进制安全。即使数据中存在'/0'
- value 最大512M

#### 数据结构

SDS （类似ArrayList）

### list

双向链表（插入有序）

- lpush/rpush
- lpop/rpop

#### 数据结构

quickList

- 元素很少。zipList（内存连续）
- 元素很多。　将多个zipList 链接成链表

### set

#### 数据结构

底层是dict。使用hash表

### hash

string 类型的 field-value 哈希表。类似`Map<String,String>`

#### 数据结构

- ziplist 
- hashtable

### zset

#### 数据结构

- hash field -> 值 ,value->score
- skiplist 
  - 有序链表

## 发布与订阅

消息通信模式

- 发布者发布消息
- 订阅者订阅（频道）

## 新数据类型

+ **Bitmaps**

  value 为0/1数组（字符串）

+ **HyperLogLog**

  基数问题。集合中不重复类型。

  使用概率算法，通过存储元素的hash值的第一个１的位置，来计算元素数量

+ **Geospatial**

  经纬度地理信息。

## Jedis使用

通过java操作redis

## SpringBoot  整合

## 事务

单独的隔离操作，命令会串行执行。

Lua 脚本有一定的原子性。可解决超卖和库存遗留问题。

#### 乐观锁

#### 悲观锁

## 持久化

#### RDB

在指定的**时间间隔**内将内存中的数据集**快照**写入磁盘

fork 一个子进程。创建一个临时文件，先写入到临时文件。然后将临时文件内容写到rdb 文件中。

会造成数据丢失。

**写时复制技术**　

一般情况下，父进程和子进程共用同一段物理内存。当父子进程有更改相应段的行为时，在为子进程分配相应内存。避免复制内存。

`fork()` 执行后，将进程所有相关页设为`read-only`。当父子进程修改内存时，引发缺页中断。中断处理程序将异常页复制一份。

`exec()`会装载一个新进程，覆盖当前进程内存空间中的映像。 

#### AOF

Append Only File. 以日志形式记录写操作（指令+数据）。

重写压缩操作。

## 主从复制

主机数据更新后根据配置和策略，自动同步到备机的 **master/slaver机制**，master　以写为主，slave 以读为主

- 读写隔离
- 容灾的快速恢复(一主多从)

#### 复制原理

1. 从服务器连接上主服务器，发送数据同步消息
2. 主服务器接受到同步消息后，先进行持久化为rdb 文件，并将rdb 文件发给从服务器
3. 主服务器进行写操作之后，和从服务器进行数据同步

#### 一主两从

1. 从服务器中途挂了?

   再次上线，变成主服务器。

   再次成为从服务器，会复制所有主服务器数据

2. 主服务器挂了?

   再次上线，依然为主服务器。

#### 薪火相传

主服务器只同步一台从服务器。由从服务器进行其他从服务器的同步

#### 反客为主

master 挂了，slave 变成主服务器

`slave no one`

#### 哨兵模式

反客为主自动版。负责监控主机是否故障，若故障，将消息发送为从，从以**投票的方式**（优先级高的，偏移量最大的，ruuid 最小的）选出主，故障机重新上线后，作为新主的从。

**复制延时**

## 集群

无中心化集群。

- 水平扩容　将数据库分别存储到集群中的N个节点中
- 一定程度的可用性　分区实现。

### slot

一个集群中含有16384个插槽，数据库中的每个兼都属于slot中的一个。

使用CRC16(key) % 16384 计算 key 对应的slot

### 故障恢复

主机挂掉后，从机变成主机。主机再次上线后，变为从。

#### Pros

扩容

#### Cons

多键操作不支持

lua 不支持

多键事务不支持

## 应用问题

### 缓存穿透

#### 现象

1. 应用服务器压力变大了
2. redis 命中率降低
3. 数据库压力增加

#### 原因

1. redis 与数据库失连
2. 非正常的url 访问

#### 解决

1. 空值缓存（过期时间变短）
2. 白名单　bitmaps
3. Bloom Filter 
4. 实时监控

### 缓存击穿

#### 现象

1. 数据库访问压力瞬时增加
2. redis 并未大量过期
3. redis 正常运行

#### 原因

1. 某个hotkey过期

#### 解决

1. 预先设置热门数据，加大过期时间
2. 实时调整
3. 使用锁

### 缓存雪崩

#### 现象

1. 数据库压力变大，服务器崩溃

#### 原因

1. 极端时间内，大量key集中过期

#### 解决

1. 多级缓存
2. 锁或者队列
3. 设置过期标志更新缓存
4. 缓存失效时间随机分散

### 分布式锁

跨JVM 互斥机制共享资源的访问。

#### 主流实现方案

1. 基于数据库
2. 基于redis
3. zookeeper

---

`setnx`实现加锁,使用`del`释放。给锁设置**过期时间**，防止忘记释放。

加锁时，同时设置过期时间，保证原子性

#### 问题1

释放了别人的锁。

#### 解决1

生成全局唯一的UUID。标记锁。在UUID相同的时候，才能释放锁。

#### 问题2

解锁的原子性(uuid 比较相同后，锁在删除前过期。导致删了别人的锁)

#### 解决2

使用lua脚本保证原子性

#### redis6新功能

#### ACL

- 用户名，密码
- 操作权限

#### IO多线程

执行命令是单线程，多线程处理网络数据读写和协议解析。

