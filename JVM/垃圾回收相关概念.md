# 目录

[TOC]

# System.gc()

`System.gc()`（底层是`Runtime.getRuntime().gc()`）会显示触发`Full GC`（对老年代和新生代回收）。但是**无法保证**一定会进行GC。

`System.ruFinalization()`强制执行无引用的对象的`finalize()`方法

## 不可达对象

# 内存溢出和内存泄漏

## OOM

没有空闲内存，并且垃圾回收器也无法提供更多内存。发生之前，会进行Minor GC , Full GC

## 内存泄漏

 只有对象不会在被程序用到了，但是GC 不能回收的情况。比如：程序中，忘记删除不使用的引用。

- 单例模式。引用了外部对象，则该外部对象内存泄漏
- 外部资源未`close()`如数据库链接

# Stop The World

垃圾回收时，暂停整个应用程序线程。因此，可以产生一个一致性快照，以便能够进行正确的引用关系分析。

**不可避免**

# 垃圾回收的并发和并行

- 并行 ：垃圾回收线程的并行
- 并发：用户线程和垃圾回收线程并发

# 安全点和安全区域

- 安全点：能够执行 STW 进行 GC 的时间点。

  - 即不能太长，也不能太短。一般将 “是否具有让程序长时间执行的特征”作为标准。如方法调用、循环跳转、异常跳转等等

  - 如何在GC时，保证所有的线程都跑到最近的安全点停顿下来？

    - 抢先式中断（目前没有虚拟机采用）

      首先中断所有线程，如果还有线程不在安全点。则恢复线程，让线程运行到安全点

    - 主动式中断

      设置一个中断标志。各个线程运行到安全点主动轮询这个标志。如果中断为真，则自己中断挂起

- 安全区域：在一段代码片段中，对象的引用关系不会发生变化，在这个区域中任何位置开始GC都是安全的

  - 例如，在线程`sleep`或者`Blocked`状态下，线程无法相应JVM中断请求。因此需要安全区域，避免线程为必须要运行到安全点，而不得不响应请求
  - 执行方式
    - 线程进入`Safe Region`时，线程标识进入。之后如果发生GC, JVM 会忽略执行已标识的线程
    - 线程离开时，JVM 检查是否完成了GC。若未完成，线程必须等待直到收到可以安全离开安全区域的信号位置



# 引用

## 为何要有引用分类？

有这样一类对象（例如缓存），若内存充足时，就保留在内存中;如果内存很紧张，则可以抛弃。只使用强引用是不能达到这个目的。因而，在jdk 1.2 后，java引入了引用分类。（引用强度依次减少。`java.lang.ref`）



- 强引用：传统的“引用”定义，“Object obj=new Object()”.无论何时进行垃圾回收时，强引用引用的对象，都不会回收（99%）
- 软引用：在发生溢出之前，会将软引用对象列入回收范围之内，进行二次回收。如果这次回收后，还是没有足够的内存，才会抛出内存异常。（缓存）
- 弱引用：被弱引用关联的对象只能生存到下一次垃圾收集之前。当GC工作时，无论内存空间是否足够，都会回收弱引用关联的对象（缓存）
- 虚引用：一个对象是否有虚引用的存在，完全不会影响其生命周期。同时，也不能通过虚引用获取对象实例。**唯一目的，是能在该对象被回收时，收到一个系统通知。可用于对象回收跟踪**

***注意：***介绍4种引用环境都是在对象被**引用链关联的情况**下

## 强引用——不回收

- 默认的引用类型
- 强引用的对象是可触及的，垃圾回收其**永远不会**回收强引用对象
- 强引用是造成内存泄漏的主要原因之一。

## 软引用——内存不足即回收

​	当GC对不可触及的对象进行第一次回收后，若发现内存依旧紧张，则将会回收被弱引用关联的对象。比如在高速缓存中，会用到软引用。如果还有空闲空间，可以暂时保留缓存，内存不足时，清理掉，从而保证，在使用缓存时，不会耗尽内存。（软引用队列）

```java
//定义软引用一
SoftRefrence<Object> softRef = new SoftRerence<Object>(new Object());
//定义软引用二
Object obj = new Object();//强引用
SoftRefrence<Object> softRef = new SoftRerence<Object>(obj);
obj=null;//解除强引用

//获取被引用对象
Object obj1=softRef.get();

```

## 弱引用——发现即回收

只被弱引用关联的对象的生命周期只能到下一次垃圾收集发生为止。即是说，发现立即回收。（弱引用队列）**弱引用回收更容易更快**

## 虚引用——对象回收跟踪

唯一目的，跟踪垃圾回收过程。创建的时候一定要传入一个引用队列。

## 终结器引用

用以调用`finalize()`方法。会将终结器引用的对象放入终结器引用队列，由`Finalizer`线程调用`finalize()`方法。





