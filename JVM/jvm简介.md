# JVM 简介

## 主要组成部分

![image-20210820134325054](/home/lzl123/.config/Typora/typora-user-images/image-20210820134325054.png)

## 运行时数据区

Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个 不同的数据区域。

![image-20210820134532726](/home/lzl123/.config/Typora/typora-user-images/image-20210820134532726.png)

- 程序计数器(Program Counter Register):当前线程所执行的字节码的行号 指示器,字节码解析器的工作是通过改变这个计数器的值,来选取下一条需要执行的 字节码指令,分支、循环、跳转、异常处理、线程恢复等基础功能,都需要依赖这个 计数器来完成;
- Java 虚拟机栈(Java Virtual Machine Stacks):用于存储局部变量表、操作 数栈、动态链接、方法出口等信息
- 本地方法栈(Native Method Stack):与虚拟机栈的作用是一样的,只不过虚 拟机栈是服务 Java方法的,而本地方法栈是为虚拟机调用 Native 方法服务的;
- Java 堆(Java Heap):Java 虚拟机中内存大的一块,是被所有线程共享 的,几乎所有的对象实例都在这里分配内存;
- 方法区(Methed Area):用于存储已被虚拟机加载的类信息、常量、静态变 量、即时编译后的代码等数据。

## 堆栈的区别

### 内存分别

堆因为是不连续的,所以分配的内存是在运行期确认的,因此大小不固定。一般 堆大小远远大于栈。
栈是连续的,所以分配的内存大小要在编译期就确认,大小是固定的。

### 存放的内容

堆存放的是对象的实例和数组。因此该区更关注的是数据的存储
栈存放:局部变量,操作数栈,返回结果。该区更关注的是程序方法的执行。
PS:

1. 静态变量放在方法区

2. 静态的对象还是放在堆。

### 程序的可见度

  堆对于整个应用程序都是共享、可见的。
  栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。

## 对象创建方式

|   Header   | 解释 |
| ---- | ---- |
| 使用new关键字 | 调用了构造函数 |
|Constructor类的newInstance方法 |调用了构造函数|
| Class的newInstance方法 | 调用了构造函数 |
| clone方法 | 调用了构造函数 |
| 反序列化 | 没有调用构造函数 |

### new 对象的创建流程

1. 检查常量池是否已经加载相应的类,如果没有, 必须先执行相应的类加载。类加载通过后,接下来分配内存。
2. Java堆中内存是 绝对规整的,使用“指针碰撞“方式分配内存;
   如果不是规整的,就从空闲列表 中分配,叫做”空闲列表“方式。
3. 划分内存时还需要考虑一个问题-并发,
   也有 两种方式: CAS同步处理,或者本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)。
4. 内存空间初始化操作,接着是做一些必要的对象设置(元信 息、哈希码...),后执行方法。

## 内存分配方式

### 指针碰撞

如果Java堆的内存是**规整**,即所有用过的内存放在一边,而空闲的的 放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小 相等的距离,这样便完成分配内存工作。

### 空闲列表

如果Java堆的内存**不是规整**的,则需要由虚拟机维护一个列表来记录 那些内存是可用的,这样在分配的时候可以从列表中查询到足够大的内存分配给对 象,并在分配后更新列表记录。

### 对象创建时的并发问题

#### 避免并发

分配内存空间的动作进行同步处理(采用 CAS + 失败重试来保障更新操作的 原子性)

#### 并发处理

本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)创建

## 双亲委派机制

### 作用

1、防止重复加载同一个`.class`。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。
2、保证核心`.class`不能被篡改。通过委托方式，不会去篡改核心`.clas`，即使篡改也不会去加载，即使加载也不会是同一个`.class`对象了。不同的加载器加载同一个`.class`也不是同一个`Class`对象。这样保证了`Class`执行安全。



